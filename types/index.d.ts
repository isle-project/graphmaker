import { Buffer } from 'node:buffer';
import type { Graph } from './graph.d.ts';

export interface Maybe<A> {
    toValue: ( this: Maybe<A>, defaultValue: A ) => Maybe<A>,
    get: ( this: Maybe<A>, key: string, defaultValue: any ) => any,
    map: <B>( this: Maybe<A>, f: (x: A) => B ) => Maybe<B>,
    join: ( this: Maybe<Maybe<A>> ) => Maybe<A>
}

export interface MaybeNothing extends Maybe<any> {
    nothing: null
}

export type Action = 'TASK' | 'SET_GRAPH' | 'UNDO' | 'REDO' | 'RESET_POSITIONS' | 'CONVERT'
export type Config = Object

/**
 * Represents the payload of an action.
 *
 * @template A - type of the action
 * @template T - type of the payload
 */
export type ActionPayload<A extends Action, T> = {
    /**
     * Action that was performed.
     */
    action: A,

    /**
     * Payload that was used to perform the action.
     */
    payload: T
}

/**
 * Token information for a message.
 */
export type TokenInfo = {
    /**
     * Number of tokens in the message.
     */
    tokenCount: number;

    /**
     * Maximum number of tokens allowed for the message per the model.
     */
    tokenLimit: number;
};

/**
 * Represents an element in the history of the graph.
 */
export type HistoryElement = {
    /**
     * The action that was performed.
     */
    action: Action,

    /**
     * The graph state after the action was performed.
     */
    graph: GraphState,

    /**
     * The payload that was used to perform the action.
     */
    payload: any,

    /**
     * The diff generated by the LLM to update the graph.
     */
    diff: string,

    /**
     * Information about the tokens used in the prompt.
     */
    promptTokens?: TokenInfo
}

/**
 * Represents the state of a graph.
 */
export type GraphState = {
    /**
     * Graph object.
     */
    graph: Graph,

    /**
     * History of the graph.
     */
    history: Array<HistoryElement>,

    /**
     * Index of the current state in the history.
     */
    historyIndex: number,

    /**
     * Configuration object for the graph.
     */
    config: Config
}

/**
 * An error that occurred during a graph update.
 */
export type UpdateError = {
    /**
     * Kind.
     */
    kind: 'ERRORS',

    /**
     * Array of errors.
     */
    data: Array<Error>,

    /**
     * Context where the error occurred.
     */
    context: any
}

/**
 * Represents text output from a graph conversion.
 */
export type TextOutput = {
    /**
     * Kind of output.
     */
    kind: 'TEXT-OUTPUT',

    /**
     * Text data.
     */
    data: string
}

/**
 * Represents binary output from a graph conversion.
 */
export type BinaryOutput = {
    /**
     * Kind of output.
     */
    kind: 'SVG-OUTPUT' | 'PDF-OUTPUT' | 'IMAGE-OUTPUT',

    /**
     * Binary data.
     */
    data: Buffer
}

/**
 * Initializes a new graph state.
 *
 * @param config - configuration options
 * @returns the initial graph state
 */
export function initializeGraph(config: Config) : GraphState

/**
 * Updates the graph state according to the given command.
 */
export function updateGraph<T>(state: GraphState, payload: ActionPayload<'TASK',T>) : Promise<[GraphState, Maybe<UpdateError>|MaybeNothing]>
export function updateGraph<T>(state: GraphState, payload: ActionPayload<'SET_GRAPH',T>) : Promise<[GraphState, Maybe<UpdateError>|MaybeNothing]>
export function updateGraph<T>(state: GraphState, payload: ActionPayload<'CONVERT',T>) : Promise<[GraphState, Maybe<BinaryOutput|TextOutput|UpdateError>]>
export function updateGraph<T>(state: GraphState, payload: ActionPayload<'REDO',T>) : Promise<[GraphState, MaybeNothing]>
export function updateGraph<T>(state: GraphState, payload: ActionPayload<'UNDO',T>) : Promise<[GraphState, MaybeNothing]>
export function updateGraph<T>(state: GraphState, payload: ActionPayload<'RESET_POSITIONS',T>) : Promise<[GraphState, MaybeNothing]>

/**
 * Returns a command to change a graph according to a user's prompt.
 *
 * @param prompt - user's prompt
 * @param oracle - LLM oracle to use for generating the diff of how to update the graph
 * @returns action payload for the task command
 */
export function task<T>( prompt: string, oracle: T) : ActionPayload<'TASK', T>

/**
 * Returns a command to set the graph to a given graph.
 *
 * @returns action payload for setting the graph
 */
export function setGraph( graph: Graph) : ActionPayload<'SET_GRAPH', Graph>

/**
 * Returns a command to reset the graph to its initial graph.
 *
 * @returns action payload for resetting the graph
 */
export function resetGraph(): ActionPayload<'SET_GRAPH', Graph>

/**
 * Returns a command to clear the _positions information in the current graph.
 *
 * @returns action payload for resetting node positions
 */
export function resetPositions(): ActionPayload<'RESET_POSITIONS',null>

/**
 * Returns a command to redo the last undone command on the graph.
 *
 * @returns action payload for the redo command
 */
export function redo(): ActionPayload<'REDO',null>

/**
 * Returns a command to undo the last command on the graph.
 *
 * @returns action payload for the undo command
 */
export function undo(): ActionPayload<'UNDO',null>

/**
 * Returns a command to convert the graph to a given format.
 *
 * @param config - configuration options
 * @returns action payload for the convert command
 */
export function convert( config: Config ): ActionPayload<'CONVERT', Config>
